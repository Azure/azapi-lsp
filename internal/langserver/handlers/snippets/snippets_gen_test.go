package snippets

import (
	"fmt"
	"os"
	"path"
	"strings"
	"testing"

	"golang.org/x/exp/slices"
)

func Test_SnippetGen(t *testing.T) {
	exampleDir := os.Getenv("AZAPI_EXAMPLE_DIR")
	if exampleDir == "" {
		t.Skip("AZAPI_EXAMPLE_DIR is not set")
	}
	folders, err := os.ReadDir(exampleDir)
	if err != nil {
		t.Fatal(err)
	}

	snippets := make([]Snippet, 0)
	for _, folder := range folders {
		if !folder.IsDir() {
			continue
		}
		filepath := path.Join(exampleDir, folder.Name(), "main.tf")
		snippet, err := parseSnippet(filepath)
		if err != nil {
			t.Fatal(err)
			continue
		}
		if snippet == nil {
			continue
		}
		snippets = append(snippets, *snippet)
	}
	slices.SortFunc(snippets, func(i, j Snippet) int {
		return strings.Compare(i.AzureResourceType, j.AzureResourceType)
	})

	format := `package snippets

// This file is generated by internal/langserver/handlers/snippets/snippets_gen_test.go
var snippetMap = map[string]Snippet{
%s
}`
	content := ""
	keyMap := make(map[string]bool)
	for _, snippet := range snippets {
		lowerResourceType := strings.ToLower(snippet.AzureResourceType)
		if _, ok := keyMap[lowerResourceType]; ok {
			continue
		}
		keyMap[lowerResourceType] = true
		fields := ""
		for _, field := range snippet.Fields {
			fields += fmt.Sprintf(`            {
		        Name:  "%s",
		        Value: %s,	
	        },
`, field.Name, fmt.Sprintf("`%s`", field.Value))
		}
		content += fmt.Sprintf(`    "%s": {
	    AzureResourceType: "%s",
	    Fields: []Field{
%s	
	    },
    },
`, lowerResourceType, snippet.AzureResourceType, fields)
	}

	content = fmt.Sprintf(format, content)
	err = os.WriteFile("gen.go", []byte(content), 0644)
	if err != nil {
		t.Fatal(err)
	}
}

func Test_parseSnippet(t *testing.T) {
	testcases := []struct {
		filepath string
		expected Snippet
	}{
		{
			filepath: "testdata/main.tf",
			expected: Snippet{
				AzureResourceType: "Microsoft.DataFactory/factories/integrationRuntimes",
				Fields: []Field{
					{
						Name:  "type",
						Value: `type      = "Microsoft.DataFactory/factories/integrationRuntimes@2018-06-01"`,
					},
					{
						Name:  "parent_id",
						Value: `parent_id = ${1:"The id of the Microsoft.DataFactory/factories@2018-06-01 resource"}`,
					},
					{
						Name:  "name",
						Value: `name      = "${2:The name of the resource}"`,
					},
					{
						Name: "body",
						Value: `body = jsonencode({
    properties = {
      description = ""
      type        = "SelfHosted"
    }
  })`,
					},
					{
						Name:  "schema_validation_enabled",
						Value: `schema_validation_enabled = false`,
					},
					{
						Name:  "response_export_values",
						Value: `response_export_values    = ["*"]`,
					},
				},
			},
		},
	}

	for _, testcase := range testcases {
		t.Logf("testing %s", testcase.filepath)
		actual, err := parseSnippet(testcase.filepath)
		if err != nil {
			t.Fatal(err)
		}
		if actual.AzureResourceType != testcase.expected.AzureResourceType {
			t.Errorf("expected %s, but got %s", testcase.expected.AzureResourceType, actual.AzureResourceType)
		}
		if len(actual.Fields) != len(testcase.expected.Fields) {
			t.Errorf("expected %d fields, but got %d", len(testcase.expected.Fields), len(actual.Fields))
		}
		for i, field := range actual.Fields {
			if field.Name != testcase.expected.Fields[i].Name {
				t.Errorf("expected %s, but got %s", testcase.expected.Fields[i].Name, field.Name)
			}
			if field.Value != testcase.expected.Fields[i].Value {
				t.Errorf("expected %s, but got %s", testcase.expected.Fields[i].Value, field.Value)
			}
		}
	}
}

func Test_PlaceholderContent(t *testing.T) {
	testcases := []struct {
		rawContent  string
		addrTypeMap map[string]string
		expected    string
	}{
		{
			rawContent:  "var.resource_name",
			addrTypeMap: map[string]string{},
			expected:    "The name of the resource",
		},
		{
			rawContent:  "var.location",
			addrTypeMap: map[string]string{},
			expected:    "location",
		},
		{
			rawContent:  "local.ip",
			addrTypeMap: map[string]string{},
			expected:    "ip",
		},
		{
			rawContent:  "azapi_resource.rg.output",
			addrTypeMap: map[string]string{},
			expected:    "TODO",
		},
		{
			rawContent: "data.azapi_resource.rg.id",
			addrTypeMap: map[string]string{
				"data.azapi_resource.rg": "Microsoft.Resources/resourceGroups@2021-04-01",
			},
			expected: "The id of the Microsoft.Resources/resourceGroups@2021-04-01 resource",
		},
		{
			rawContent: "azapi_resource.rg.id",
			addrTypeMap: map[string]string{
				"azapi_resource.rg": "Microsoft.Resources/resourceGroups@2021-04-01",
			},
			expected: "The id of the Microsoft.Resources/resourceGroups@2021-04-01 resource",
		},
		{
			rawContent: "data.azapi_resource.rg.foo",
			addrTypeMap: map[string]string{
				"data.azapi_resource.rg": "Microsoft.Resources/resourceGroups@2021-04-01",
			},
			expected: "The foo of the Microsoft.Resources/resourceGroups@2021-04-01 resource",
		},
		{
			rawContent: "azapi_resource.rg.foo",
			addrTypeMap: map[string]string{
				"azapi_resource.rg": "Microsoft.Resources/resourceGroups@2021-04-01",
			},
			expected: "The foo of the Microsoft.Resources/resourceGroups@2021-04-01 resource",
		},
	}
	for _, testcase := range testcases {
		t.Logf("testing %s", testcase.rawContent)
		actual := placeholderContent(testcase.rawContent, testcase.addrTypeMap)
		if actual != testcase.expected {
			t.Errorf("expected %s, but got %s", testcase.expected, actual)
		}
	}
}
